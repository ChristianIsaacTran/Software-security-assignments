/* Homework 1 - Secret Key Using Public Key, revised (has signature elements)

 * Christian Tran - R#11641653
 * 
 * This program demonstrates the secret key exchange between A (Alex) and B (Bob)
 * using a secret key, public key pairs (public and private keys), signatures, and RSA encryption and decryption algorithms.
 * Takes the secret key generated by Alex and makes 2 SEPARATE items:
 * 1 signature generated off of the original secret key created
 * 1 physical secret key encrypted
 * 
 * After generating the signature off of the original secret key and encrypting the secret key, we send both of those items over to Bob
 * and Bob will verify if the signature is valid from Alex's public key (since we generated the signature with Alex's private key) and
 * we will decrypt the secret key sent using Bob's private key (since we encrypted the secret key with Bob's public key before sending) and
 * stores it in Bob's secret key variable (SecKey).
 * ExchangeTest's main method compares if the two keys after the exchange are the same, and displays a message if it is indeed the same.
 */

//Importing Key methods
import javax.crypto.Cipher;
//import java.util.Base64; //Not used
//import java.util.Scanner; //Not used
//import java.security.MessageDigest; //Not used
import java.security.KeyPairGenerator;
import java.security.KeyPair;
import java.security.PublicKey;
import java.security.PrivateKey;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.Signature;


class Encryption
{
	static byte[] encrypt(byte s[], Cipher c, PublicKey pubKey) throws Exception
	{
	    c.init(Cipher.ENCRYPT_MODE, pubKey);
	    return c.doFinal(s);
	}

	static byte[] decrypt(byte s[], Cipher c, PrivateKey prvKey) throws Exception
	{
	    c.init(Cipher.DECRYPT_MODE, prvKey);
	    return c.doFinal(s);
	}
}



//Digital Signature Class/Algorithm???
/*Note: when making key pairs, make sure you know which algorithm key pair you used. RSA key pairs do not work with DSA stuff and vice versa and so on.
 * 
 */
class DigitalSignature
{
	public static byte[] sign(byte message[],PrivateKey prvk) throws Exception
	{
		Signature sg = Signature.getInstance("SHA256withRSA"); //Changed to RSA to sign with RSA key pairs
	    sg.initSign(prvk);
	    sg.update(message);
	    return sg.sign();
	}


	public static boolean verify (byte message[], PublicKey pubk, byte[] signature) throws Exception
	{
   	    Signature sg = Signature.getInstance("SHA256withRSA"); //Changed to RSA to sign with RSA key pairs
	    sg.initVerify(pubk);
	    sg.update(message);
	    return sg.verify(signature);
	}
}


//Alex Class
class Alex{
	private static PublicKey pubKey; //Alex Public Key
	private static PrivateKey privKey; //Alex Private Key
	private static SecretKey SecKey; //Alex Secret Key
	
	//Set methods for setting private and public key from ExchangeTest
	static void setPrivKey(PrivateKey inputKey) {
		privKey = inputKey;
	}
	
	static void setPubKey(PublicKey inputKey) {
		pubKey = inputKey;
	}
	
	//Get methods for getting the private and public key
	static PrivateKey getPrivKey() {
		return privKey;
	}
	
	static PublicKey getPubKey() {
		return pubKey;
	}
	
	static SecretKey getSecKey() {
		return SecKey;
	}
	
	//Generates secret key for AES algorithm and stores it in the secretKey Variable
	static void generateKey() {
		try{
			KeyGenerator Secretkeygen = KeyGenerator.getInstance("AES"); //Generate secret key through AES algorithm 
			Secretkeygen.init(128); //Setting the key size???
			SecKey = Secretkeygen.generateKey(); //Stores the generated secret key into the SecKey variable to send to Bob
			
			//Display generated secret key from Alex to the user
			byte[] temp = SecKey.getEncoded();
			String str = new String(temp);
			System.out.println("This is Alex's generated secret key = "+str+"\n");
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}
	
	
	//sends the secret key to bob class by calling receiveKey operation provided by the bob class
	//Before sending the secret key, Alex has to SIGN the secret key using Alex's private key and then encrypt it using bob's public key
	static void sendKey() {
		try {
			//Generating digital signature for the secret key
			byte[] raw_seckey_data = SecKey.getEncoded(); //Secret key turns into byte data using encode
			byte[] digital_sig = DigitalSignature.sign(raw_seckey_data, Alex.getPrivKey()); //Generates a signature using Alex's private key
			
			//Encryption after signing 
			
			/*Note to self: THIS IS WHERE I STOPPED LAST NIGHT. I NEEDED TO FINISH THE ENCRYPTION PART BUT I CAN'T FIGURE IT OUT. I AM EMAILING THE PROFESSOR FOR HELP
			 * 9/17/2023
			 */
			
			/*Note to self: After emailing the TA, I have confirmed what they want us to do is to send 2 SEPARATE things to Bob:
			 * 1 signature for verification generated from the secretkey in this case, the raw_seckey_data because it needs to be transferred into a byte array with an encoder
			 * 1 encrypted key for decryption when Bob gets it 
			 * 
			 * We keep them separate because the TA explained that the signature and the encrypted key are sent as a dual package to Bob for verification (signature) and for the
			 * actual key (the encrypted key).
			 * 
			 * This entire time, the assignment was NOT to encrypt a signed secret key, but to just have a encrypted secret key and a digital_signature for verification
			 * (because generating a digital signature from the key itself and not a signed key is 2 very different things)
			 */
			
			Cipher rsaCipher = Cipher.getInstance("RSA/ECB/PKCS1Padding"); //rsaCipher
			
		    byte[] encryptedKey = Encryption.encrypt(raw_seckey_data, rsaCipher, Bob.getPubKey()); //Encrypts the secret key using Bob's public key
			
			 //Calls receiveKey() operation from Bob class to send the key 
			Bob.receiveKey(raw_seckey_data,digital_sig, encryptedKey, rsaCipher);
		
		}
		catch(Exception e) {
			e.printStackTrace();
		}
	}
	
	
}


//Bob Class
class Bob{
	private static PublicKey pubKey; //Bob Public Key
	private static PrivateKey privKey; //Bob Private Key
	private static SecretKey SecKey; //Bob Secret Key
	
	//Set methods for setting private and public key from ExchangeTest
		static void setPrivKey(PrivateKey inputKey) {
			privKey = inputKey;
		}
		
		static void setPubKey(PublicKey inputKey) {
			pubKey = inputKey;
		}
	
	//Get methods for getting the private and public key
		static PrivateKey getPrivKey() {
			return privKey;
		}
		
		static PublicKey getPubKey() {
			return pubKey;
		}
		
		static SecretKey getSecKey() {
			return SecKey;
		}
	
    //ONLY decrypts the key sent from Alex IF the signature from the key is valid and not changed. If it is verified to be good, decrypt the key and store the secret key in SecKey. If not, 
	//print out error and display error message.
	static void receiveKey(byte[] raw_seckey_data, byte[] signature, byte[] encryptedKey, Cipher rsaCipher) {
		try {
			//Attempts to verify if the signature sent from Alex is valid and not changed using Alex's public key and the signature also sent from Alex. Store boolean into result variable
			boolean result = DigitalSignature.verify(raw_seckey_data, Alex.getPubKey(), signature);
			
			//Display whether the signature was verified or not to the user
			System.out.println("Is the signature from Alex valid? "+result+"\n");
			
			//If the result of the verification is true (verified correctly) then decrypt the secretkey and store in Bob's SecKey variable 
			if(result == true) {
				//Decrypts the sent encryptedKey with Bob's private key since he encrypted it with his public key back in Alex's method. After successfully decrypting, store now decrypted
				//key into Bob's SecKey attribute to complete the exchange
				byte[] decrypted_seckey = Encryption.decrypt(encryptedKey, rsaCipher, Bob.getPrivKey());
				
				//Now since we encoded the secret key back in Alex's method, we have to re-convert it back to a SecretKey object instead of just a byte[] using SecretKeySpec
				//Note: SecretKeySpec: it is used to create a secret key off of a given byte array
				
				SecKey = new SecretKeySpec(decrypted_seckey, 0, decrypted_seckey.length, "AES"); //Re-creates the secret key from Alex using the decrypted_seckey byte[] data, should be the same
				
				//Display the current secret key from Bob to user
				byte[] temp = SecKey.getEncoded();
				String str = new String(temp);
				System.out.println("This is Bob's secret key after verifying signature and decrypting = "+str+"\n");
				
			}
		}
		catch(Exception e) {
			e.printStackTrace();
		}
	}
	
}




//Exchange Test Class
/*Creates a pair of public and private keys for the RSA algorithm for each Alex and Bob classes
 * and stores the keys in publicKey and privateKey in Alex and Bob classes by calling the set() operations
 * ExchangeTest also calls the generateKey() and sendKey() in the Alex class, then compares the secret keys in the Alex and Bob 
 * Classes to see if they are the same.
 */
public class ExchangeTest {

	public static void main(String[] args) {
		try{
			//Note: KeyPairGenerator is used for public and private key pair, KeyGenerator is just for 1 secret key
			KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA"); //In this case we are creating pairs of public and private keys from RSA algorithm for each of Alex and Bob
			keyPairGen.initialize(512); // 512 is the key size. Default key size can be 512 or bigger
			
			//Create Alex's Keys
			KeyPair AlexKeyPair = keyPairGen.generateKeyPair(); //Generate a key pair for Alex
			PublicKey AlexPublicKey = AlexKeyPair.getPublic(); //Get the public key out of the pair
			PrivateKey AlexPrivateKey = AlexKeyPair.getPrivate(); //Get the private key out of the pair
			Alex.setPubKey(AlexPublicKey); //Set generated public key for Alex
			Alex.setPrivKey(AlexPrivateKey); //Set generated private key for Alex
			
			//Create Bob's Keys
			KeyPair BobKeyPair = keyPairGen.generateKeyPair(); //Generate a key pair for Bob
			PublicKey BobPublicKey = BobKeyPair.getPublic(); //Get the public key out of the pair
			PrivateKey BobPrivateKey = BobKeyPair.getPrivate(); //Get the private key out of the pair
			Bob.setPubKey(BobPublicKey); //Set generated public key for Bob
			Bob.setPrivKey(BobPrivateKey); //Set generated private key for Bob
			
			//Calling Alex generateKey() and sendKey() operations
			Alex.generateKey(); //Generates the SecretKey to send between Alex to Bob (A -> B)
			
			Alex.sendKey(); //Signs, Encrypts, then sends the key to Bob
			
			//Compare if both secret keys in Alex and Bob Classes are the same. Display message if the are or aren't the same key using .equals() to compare the content of the objects
			//rather than the reference location of the object (== vs .equals())
			if(Bob.getSecKey().equals(Alex.getSecKey())) {
				System.out.println("Are Alex and Bob secret key the same after the exchange? TRUE - Verified");
			}
			else {
				System.out.println("Are Alex and Bob secret key the same after the exchange? FALSE - not the same key after exchange");
			}
			
		 	}
			catch (Exception e){
		 		e.printStackTrace();
		 	}

	}

}
